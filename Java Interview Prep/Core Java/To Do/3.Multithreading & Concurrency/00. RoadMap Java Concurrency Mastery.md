# Java Concurrency Mastery Roadmap â€” SDE Interview Edition

---

## The Roadmap 

```
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                JAVA CONCURRENCY MASTERY ROADMAP  â€”â€”  SDE INTERVIEW EDITION                   â•‘
    â•‘                            ( 10 - 12 Weeks Plan )                                            â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          WEEK 1            WEEK 2-3           WEEK 4-5          WEEK 6-7          WEEK 8-9        WEEK 10-12
            â”‚                  â”‚                  â”‚                  â”‚                 â”‚                â”‚
            â–¼                  â–¼                  â–¼                  â–¼                 â–¼                â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   [ LEVEL 0 ]   â”‚ â”‚  [ LEVEL 1 ]  â”‚ â”‚  [ LEVEL 2 ]  â”‚ â”‚  [ LEVEL 3]  â”‚ â”‚  [ LEVEL 4 ] â”‚ â”‚   [ LEVEL 5 ]    â”‚
   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚ â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
   â”‚  PREREQUISITES  â”‚ â”‚  FOUNDATION   â”‚ â”‚    j.u.c      â”‚ â”‚   ADVANCED   â”‚ â”‚ SPRING BOOT  â”‚ â”‚ INTERVIEW READY  â”‚
   â”‚  & JVM BASICS   â”‚ â”‚  THREADING    â”‚ â”‚  FRAMEWORK    â”‚ â”‚    TOPICS    â”‚ â”‚ CONCURRENCY  â”‚ â”‚  + REAL WORLD    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                 â”‚                  â”‚                  â”‚                â”‚                  â”‚
            â”‚                 â”‚                  â”‚                  â”‚                â”‚                  â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ â€¢ JVM: Stack,   â”‚ â”‚ â€¢ Thread      â”‚ â”‚ â€¢ Executor    â”‚ â”‚ â€¢ ForkJoin   â”‚ â”‚ â€¢ @Async     â”‚ â”‚ â€¢ Coding Qs      â”‚
   â”‚   Heap, Method  â”‚ â”‚   Runnable    â”‚ â”‚   Service     â”‚ â”‚   Pool       â”‚ â”‚ â€¢ @Scheduled â”‚ â”‚ â€¢ Design Qs      â”‚
   â”‚   Area          â”‚ â”‚   Callable    â”‚ â”‚ â€¢ Thread Pool â”‚ â”‚ â€¢ Recursive  â”‚ â”‚ â€¢ Task       â”‚ â”‚ â€¢ DeadLock Qs    â”‚
   â”‚ â€¢ What is a     â”‚ â”‚ â€¢ Thread      â”‚ â”‚   Executor    â”‚ â”‚   Task &     â”‚ â”‚   Executor   â”‚ â”‚ â€¢ Producer       â”‚
   â”‚   Thread vs     â”‚ â”‚   LifeCycle   â”‚ â”‚ â€¢ Callable +  â”‚ â”‚   Action     â”‚ â”‚ â€¢ Spring     â”‚ â”‚   Consumer       â”‚
   â”‚   Process       â”‚ â”‚   (6 states)  â”‚ â”‚   Future      â”‚ â”‚ â€¢ Parallel   â”‚ â”‚   Tx Mgmt    â”‚ â”‚ â€¢ Race Cond.     â”‚
   â”‚ â€¢ Race Cond.    â”‚ â”‚ â€¢ synchronizedâ”‚ â”‚ â€¢ Completable â”‚ â”‚   Streams    â”‚ â”‚   Isolation  â”‚ â”‚ â€¢ Sync Problems  â”‚
   â”‚   concept       â”‚ â”‚   keyword     â”‚ â”‚   Future      â”‚ â”‚ â€¢ AQS        â”‚ â”‚ â€¢ Spring     â”‚ â”‚ â€¢ ThreadLocal    â”‚
   â”‚ â€¢ Visibility    â”‚ â”‚ â€¢ volatile    â”‚ â”‚ â€¢ Atomic Vars â”‚ â”‚   (concept)  â”‚ â”‚   Webflux    â”‚ â”‚   Pitfalls       â”‚
   â”‚   problem       â”‚ â”‚ â€¢ wait/notify â”‚ â”‚ â€¢ Concurrent  â”‚ â”‚ â€¢ LongAdder  â”‚ â”‚   intro      â”‚ â”‚ â€¢ Virtual Thread â”‚
   â”‚ â€¢ Happens-      â”‚ â”‚   notifyAll   â”‚ â”‚   Collections â”‚ â”‚ â€¢ VarHandle  â”‚ â”‚ â€¢ R2DBC      â”‚ â”‚   questions      â”‚
   â”‚   Before rule   â”‚ â”‚ â€¢ join/sleep  â”‚ â”‚ â€¢ Blocking    â”‚ â”‚   concept    â”‚ â”‚   basics     â”‚ â”‚ â€¢ System Design  â”‚
   â”‚ â€¢ Java Memory   â”‚ â”‚ â€¢ interrupt   â”‚ â”‚   Queue       â”‚ â”‚ â€¢ StampedLck â”‚ â”‚ â€¢ DB Conn    â”‚ â”‚   with           â”‚
   â”‚   Model (JMM)   â”‚ â”‚ â€¢ ThreadLocal â”‚ â”‚ â€¢ Synchro-    â”‚ â”‚ â€¢ ThreadPool â”‚ â”‚   Pool       â”‚ â”‚   Concurrency    â”‚
   â”‚ â€¢ CPU Caching   â”‚ â”‚ â€¢ Deadlock    â”‚ â”‚   nizers      â”‚ â”‚   Sizing     â”‚ â”‚   HikariCP   â”‚ â”‚ â€¢ Mock           â”‚
   â”‚   & Reordering  â”‚ â”‚   (concept)   â”‚ â”‚   â†“           â”‚ â”‚ â€¢ Lock Free  â”‚ â”‚ â€¢ Cache      â”‚ â”‚   Interviews     â”‚
   â”‚                 â”‚ â”‚ â€¢ Liveness    â”‚ â”‚ CountDownLatchâ”‚ â”‚   Algorithms â”‚ â”‚   Concurr.   â”‚ â”‚                  â”‚
   â”‚                 â”‚ â”‚   problems    â”‚ â”‚ CyclicBarrier â”‚ â”‚ â€¢ Memory     â”‚ â”‚   (Redis)    â”‚ â”‚                  â”‚
   â”‚                 â”‚ â”‚               â”‚ â”‚ Semaphore     â”‚ â”‚   Leaks in   â”‚ â”‚              â”‚ â”‚                  â”‚
   â”‚                 â”‚ â”‚               â”‚ â”‚ Phaser        â”‚ â”‚   Threads    â”‚ â”‚              â”‚ â”‚                  â”‚
   â”‚                 â”‚ â”‚               â”‚ â”‚ Exchanger     â”‚ â”‚ â€¢ Java 21    â”‚ â”‚              â”‚ â”‚                  â”‚
   â”‚                 â”‚ â”‚               â”‚ â”‚ â€¢ Locks       â”‚ â”‚   Virtual    â”‚ â”‚              â”‚ â”‚                  â”‚
   â”‚                 â”‚ â”‚               â”‚ â”‚   Reentrant   â”‚ â”‚   Threads    â”‚ â”‚              â”‚ â”‚                  â”‚
   â”‚                 â”‚ â”‚               â”‚ â”‚   ReadWrite   â”‚ â”‚              â”‚ â”‚              â”‚ â”‚                  â”‚
   â”‚                 â”‚ â”‚               â”‚ â”‚   Condition   â”‚ â”‚              â”‚ â”‚              â”‚ â”‚                  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                 â”‚                 â”‚                 â”‚                â”‚                  â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ INTERVIEW WT:   â”‚ â”‚ INTERVIEW WT: â”‚ â”‚ INTERVIEW WT: â”‚ â”‚INTERVIEW WT: â”‚ â”‚INTERVIEW WT: â”‚ â”‚ INTERVIEW WT:    â”‚
   â”‚    â˜…â˜…â˜†â˜†â˜†      â”‚ â”‚   â˜…â˜…â˜…â˜…â˜†    â”‚ â”‚   â˜…â˜…â˜…â˜…â˜…    â”‚ â”‚   â˜…â˜…â˜…â˜…â˜†    â”‚ â”‚   â˜…â˜…â˜…â˜†â˜†    â”‚ â”‚    â˜…â˜…â˜…â˜…â˜…      â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


CONCURRENCY CONCEPTS DEPENDENCY TREE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚  VIRTUAL THREADS â”‚  Java 21
                              â”‚  Struct. Conc.   â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚ builds on
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚                       â”‚                       â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  CompletableFuture  â”‚ â”‚    ForkJoinPool     â”‚ â”‚   Parallel Streams   â”‚
    â”‚  (async pipelines)  â”‚ â”‚ (divide & conquer)  â”‚ â”‚  (data parallelism)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚                       â”‚                        â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚ builds on
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚                       â”‚                       â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ExecutorService   â”‚  â”‚   Atomic Variables   â”‚ â”‚  Concurrent        â”‚
    â”‚  ThreadPoolExec.   â”‚  â”‚   LongAdder / CAS    â”‚ â”‚  Collections       â”‚
    â”‚  ScheduledExec.    â”‚  â”‚   Lock-free          â”‚ â”‚  ConcurrentHashMap â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚                       â”‚                        â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚ builds on
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚                       â”‚                       â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Callable / Future â”‚  â”‚  ReentrantLock       â”‚ â”‚  Synchronizers      â”‚
    â”‚  (results from     â”‚  â”‚  ReadWriteLock       â”‚ â”‚  CountDownLatch     â”‚
    â”‚   threads)         â”‚  â”‚  StampedLock         â”‚ â”‚  CyclicBarrier      â”‚
    â”‚                    â”‚  â”‚  Condition           â”‚ â”‚  Semaphore, Phaser  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚                       â”‚                        â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚ builds on
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                  â”‚                   â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  synchronized   â”‚ â”‚    volatile       â”‚ â”‚  wait/notify        â”‚
         â”‚  (intrinsic     â”‚ â”‚  (visibility +    â”‚ â”‚  notifyAll / join   â”‚
         â”‚   lock)         â”‚ â”‚   happens-before) â”‚ â”‚  (coordination)     â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚                  â”‚                    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚ builds on
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                  â”‚                   â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Thread         â”‚ â”‚  Java Memory      â”‚ â”‚  JVM Architecture  â”‚
         â”‚  Runnable       â”‚ â”‚  Model (JMM)      â”‚ â”‚  Stack / Heap      â”‚
         â”‚  Thread States  â”‚ â”‚  Happens-Before   â”‚ â”‚  Per-thread Stack  â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    FOUNDATION


WHAT AN INTERVIEWER ACTUALLY TESTS  (by company level)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  STARTUP / MID-LEVEL SDE              FAANG / SENIOR SDE
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  âœ” Thread lifecycle                   âœ” All of mid-level +
  âœ” synchronized vs volatile           âœ” AQS internals (concept level)
  âœ” Deadlock (detect + fix)            âœ” Lock-free CAS based algorithms
  âœ” ExecutorService + ThreadPool       âœ” Memory model + happens-before
  âœ” Future + CompletableFuture         âœ” ThreadPoolExecutor tuning
  âœ” CountDownLatch / Semaphore         âœ” False sharing / cache lines
  âœ” ConcurrentHashMap internals        âœ” Custom synchronizer via AQS
  âœ” Producer-Consumer problem          âœ” ForkJoin + Parallel Streams
  âœ” @Async in Spring Boot              âœ” Virtual Threads (Java 21)
  âœ” Basic Thread Pool sizing           âœ” System design with concurrency


THREAD POOL SIZING QUICK GUIDE (interview must-know)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  CPU-BOUND tasks:                I/O-BOUND tasks:
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  pool size = N cores             pool size = N cores Ã— (1 + wait/compute ratio)
  or N+1 cores                    e.g. 8 cores, 90% I/O wait time:
                                  8 Ã— (1 + 0.9/0.1) = 8 Ã— 10 = ~80 threads
                                  Rule of thumb: 2Ã— to 10Ã— core count


COMMON CONCURRENCY PROBLEMS EVERY INTERVIEWER ASKS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚     PROBLEM      â”‚       ROOT CAUSE          â”‚          SOLUTION            â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ Race Condition   â”‚ Unsynchronized shared     â”‚ synchronized / AtomicInteger â”‚
  â”‚                  â”‚ mutable state             â”‚ / ReentrantLock              â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ Deadlock         â”‚ Circular lock dependency  â”‚ Lock ordering / tryLock() /  â”‚
  â”‚                  â”‚                           â”‚ timeout / lock hierarchy     â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ Livelock         â”‚ Threads keep responding   â”‚ Randomize retry / backoff    â”‚
  â”‚                  â”‚ to each other, no progressâ”‚                              â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ Starvation       â”‚ Low-priority threads neverâ”‚ Fair locks / fair scheduling â”‚
  â”‚                  â”‚ get CPU time              â”‚ new ReentrantLock(true)      â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ Visibility Bug   â”‚ CPU cache not flushed to  â”‚ volatile / synchronized /    â”‚
  â”‚                  â”‚ main memory               â”‚ AtomicReference              â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ Missed Signal    â”‚ notify() before wait()    â”‚ Always check condition in    â”‚
  â”‚                  â”‚                           â”‚ while loop                   â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ Memory Leak      â”‚ ThreadLocal not removed   â”‚ Always threadLocal.remove()  â”‚
  â”‚                  â”‚ in thread pool threads    â”‚ in finally block             â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Detailed Roadmap â€” Week by Week

---

### âš¡ Level 0 â€” Prerequisites & JVM Basics (Week 1)

**Why this first:**
Every concurrency bug, every keyword, every tool â€” all exist because of how the JVM and CPU hardware work. Without this, you'll memorize syntax but never truly understand WHY things break.

**Topics:**

```
1. What is a Process vs Thread
   - Process = isolated memory space
   - Thread = lightweight, shares heap with other threads in same process
   - JVM = one process, multiple threads sharing the heap

2. JVM Memory Areas relevant to concurrency
   - Heap          â†’ shared by ALL threads (where objects live)
   - Thread Stack  â†’ private to EACH thread (local vars, method calls)
   - CPU Registers â†’ private to each CPU core (fastest cache)
   - CPU L1/L2/L3 Cache â†’ between register and main memory

3. The Visibility Problem (WHY volatile exists)
   - Thread A writes x=1 to its CPU cache
   - Thread B reads x â€” might still see x=0 (CPU cache not flushed yet)
   - volatile forces write to main memory and read from main memory

4. The Reordering Problem (WHY happens-before exists)
   - JVM and CPU are free to reorder instructions for performance
   - Thread A: a=1; flag=true; might become flag=true; a=1; (reordered)
   - Thread B sees flag=true but reads a=0 â†’ incorrect behavior

5. Java Memory Model (JMM)
   - The contract between JVM and developer
   - Defines when writes by one thread become visible to others
   - The Happens-Before relationship:
     unlock happens-before lock on same monitor
     write to volatile happens-before read of same volatile
     thread.start() happens-before any code in that thread
     thread finishes happens-before thread.join() returns

6. Race Condition (concept)
   - Two threads read-modify-write same variable without synchronization
   - counter++ is NOT atomic (it is: read counter, add 1, write counter)
   - 3 separate operations â†’ thread can be interrupted between any two
```

**Practice:**
- Draw the JVM memory layout and trace what happens with two threads modifying a shared counter
- Write a simple race condition bug, see it manifest, then fix it three ways (synchronized, volatile, AtomicInteger)

---

### ğŸ§± Level 1 â€” Foundation Threading (Week 2-3)

**Topics with interview weight:**

```
1. Thread and Runnable               â˜…â˜…â˜…â˜…â˜…
   - Thread extends / Runnable implements
   - Why Runnable is preferred over extending Thread
   - Thread.currentThread(), Thread.getName(), Thread.setName()

2. Thread Lifecycle â€” 6 States       â˜…â˜…â˜…â˜…â˜…
   NEW â†’ RUNNABLE â†’ BLOCKED â†’ WAITING â†’ TIMED_WAITING â†’ TERMINATED
   Know every transition:
   - start()              â†’ NEW       to RUNNABLE
   - synchronized blocked â†’ RUNNABLE  to BLOCKED
   - wait()               â†’ RUNNABLE  to WAITING
   - wait(timeout)        â†’ RUNNABLE  to TIMED_WAITING
   - sleep()              â†’ RUNNABLE  to TIMED_WAITING
   - notify()             â†’ WAITING   to BLOCKED (waiting for lock)
   - join()               â†’ calling thread to WAITING

3. synchronized keyword              â˜…â˜…â˜…â˜…â˜…
   - Instance method     â†’ locks on 'this' object
   - Static method       â†’ locks on Class object
   - Synchronized block  â†’ locks on specified object
   - Reentrant (same thread can re-enter its own lock)

4. volatile keyword                  â˜…â˜…â˜…â˜…â˜†
   - Guarantees visibility (no CPU cache)
   - Guarantees happens-before for reads/writes
   - Does NOT guarantee atomicity (i++ is still not safe with volatile)
   - Use for: flags, state variables read by many / written by one

5. wait() / notify() / notifyAll()   â˜…â˜…â˜…â˜…â˜…
   - (covered in depth in previous story)
   - Always in synchronized, always while loop

6. join() / sleep() / interrupt()    â˜…â˜…â˜…â˜…â˜†
   - join()      â†’ wait for thread to die
   - sleep()     â†’ pause current thread (does NOT release lock)
   - interrupt() â†’ set interrupt flag (does not kill thread immediately)
   - isInterrupted() vs interrupted() (instance vs static, clears flag or not)

7. ThreadLocal<T>                    â˜…â˜…â˜…â˜…â˜†
   - Per-thread storage â€” each thread has its own copy
   - Common use: storing user session, DB connection, security context
   - DANGER: in thread pools, always call remove() in finally block
     (threads are reused â€” stale ThreadLocal data leaks across requests)

8. Deadlock                          â˜…â˜…â˜…â˜…â˜…
   - Four conditions (Coffman conditions):
     1. Mutual Exclusion
     2. Hold and Wait
     3. No Preemption
     4. Circular Wait
   - How to detect: thread dump (jstack), deadlock detection in JConsole
   - How to prevent:
     Always acquire locks in consistent order
     Use tryLock(timeout) from ReentrantLock
     Use lock hierarchy / lock leveling

9. Liveness problems                 â˜…â˜…â˜…â˜†â˜†
   - Livelock: threads respond to each other but make no progress
   - Starvation: thread never gets CPU time (fix: fair locks)
```

**Practice problems:**
- Implement a thread-safe singleton (double-checked locking â€” and explain why volatile is needed)
- Implement a simple producer-consumer with wait/notify
- Write a program that deliberately deadlocks, then fix it

---

### âš™ï¸ Level 2 â€” java.util.concurrent Framework (Week 4-5)

**This is the highest-interview-weight section. Most interview questions come from here.**

```
1. ExecutorService & ThreadPoolExecutor              â˜…â˜…â˜…â˜…â˜…
   - Executors.newFixedThreadPool(n)
   - Executors.newCachedThreadPool()
   - Executors.newSingleThreadExecutor()
   - Why you should prefer explicit ThreadPoolExecutor over factory methods
   - Know all 7 constructor parameters of ThreadPoolExecutor:
     corePoolSize, maximumPoolSize, keepAliveTime, unit,
     workQueue, threadFactory, rejectedExecutionHandler
   - Know all RejectedExecutionHandler policies:
     AbortPolicy (default â€” throws RejectedExecutionException)
     CallerRunsPolicy (caller thread runs the task â€” natural backpressure)
     DiscardPolicy (silently drops)
     DiscardOldestPolicy (drops oldest waiting task)
   - Lifecycle: submit â†’ shutdown â†’ awaitTermination

2. Callable and Future                               â˜…â˜…â˜…â˜…â˜…
   - Callable vs Runnable (returns value, throws checked exception)
   - Future.get() â€” blocking
   - Future.get(timeout, unit) â€” bounded blocking
   - Future.cancel(mayInterruptIfRunning)
   - Future.isDone() / isCancelled()
   - ExecutionException wraps exception thrown inside Callable

3. CompletableFuture                                 â˜…â˜…â˜…â˜…â˜…
   - supplyAsync(Supplier, executor)
   - thenApply(Function)    â†’ transform result (sync)
   - thenCompose(Function)  â†’ chain another async step (flatMap)
   - thenCombine(CF, BiFunction) â†’ combine two independent CFs
   - thenAccept(Consumer)   â†’ consume result, return Void
   - thenRun(Runnable)      â†’ run after, no input/output
   - exceptionally(Function) â†’ handle errors in chain
   - handle(BiFunction)     â†’ handle both result and error
   - allOf(CF...)           â†’ wait for all
   - anyOf(CF...)           â†’ take first to complete
   - join() vs get()        â†’ join() throws unchecked, get() throws checked

4. Atomic Variables                                  â˜…â˜…â˜…â˜…â˜†
   - AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference
   - compareAndSet(expected, update) â€” CAS operation
   - getAndIncrement() / incrementAndGet()
   - LongAdder â€” better than AtomicLong under high contention
     (uses striping â€” multiple cells, reduced contention)
   - When to use: simple counters, flags, references â€” no lock needed

5. Concurrent Collections                            â˜…â˜…â˜…â˜…â˜…
   - ConcurrentHashMap:
     Java 7: segment-level locking (16 segments by default)
     Java 8+: CAS + node-level locking (much finer granularity)
     putIfAbsent, computeIfAbsent, merge â€” atomic compound ops
     size() is approximate (not locked)
   - CopyOnWriteArrayList / CopyOnWriteArraySet:
     Every write creates a new copy of underlying array
     Reads are lock-free (snapshot)
     Best for: few writes, many reads, small collections
   - LinkedBlockingQueue / ArrayBlockingQueue:
     Bounded vs unbounded queue
     put() blocks when full, take() blocks when empty
   - ConcurrentLinkedQueue: non-blocking, lock-free queue (CAS-based)
   - Collections.synchronizedList() vs ConcurrentHashMap:
     synchronized wrappers lock entire collection per method
     compound operations (check-then-act) still need external sync
     ConcurrentHashMap provides atomic compound ops natively

6. ReentrantLock and Condition                       â˜…â˜…â˜…â˜…â˜…
   - Advantages over synchronized:
     tryLock() â€” non-blocking attempt
     tryLock(timeout, unit) â€” bounded wait
     lockInterruptibly() â€” respond to interrupt
     Fairness mode: new ReentrantLock(true)
     Multiple Conditions per lock
   - Always unlock in finally block
   - Condition.await() vs wait()
     await() â†’ must hold ReentrantLock (not synchronized)
     More than one condition per lock is the main advantage

7. ReadWriteLock / ReentrantReadWriteLock            â˜…â˜…â˜…â˜†â˜†
   - Multiple readers OR one writer (never both)
   - readLock() â€” shared (multiple can hold simultaneously)
   - writeLock() â€” exclusive (one at a time, blocks all readers)
   - When to use: data mostly read, occasionally updated
     (e.g. configuration map, caches)

8. StampedLock (Java 8)                              â˜…â˜…â˜…â˜†â˜†
   - Adds optimistic reading on top of read/write
   - tryOptimisticRead() â€” get a stamp without locking
   - validate(stamp) â€” check if any write happened since stamp
   - If validate fails â†’ fall back to full readLock
   - Best throughput for read-heavy scenarios

9. Synchronizers                                     â˜…â˜…â˜…â˜…â˜…
   CountDownLatch:
   - One-time countdown (cannot be reset)
   - Use: wait for N services/threads to start or finish
   - await() â€” wait for count to reach 0
   - countDown() â€” decrement count

   CyclicBarrier:
   - All N parties wait at barrier before any proceeds
   - Can be reset and reused (unlike CountDownLatch)
   - Use: parallel phases of computation, data processing stages
   - await() â€” arrive and wait for others
   - Optional Runnable triggered when barrier trips

   Semaphore:
   - N permits â€” limits concurrent access
   - acquire() â€” take a permit (block if none)
   - release() â€” return a permit
   - Use: connection pools, rate limiting, bounded resources

   Phaser (Java 7):
   - Flexible barrier â€” dynamic party registration
   - Combines CountDownLatch + CyclicBarrier features
   - register()/deregister() â€” add/remove parties dynamically
   - Use: complex multi-phase tasks with variable participants

   Exchanger:
   - Two threads swap objects at a rendezvous point
   - Use: pipeline stages, genetic algorithms, double-buffering
   - exchange(V) â€” give your object, receive theirs

10. BlockingQueue Implementations                    â˜…â˜…â˜…â˜…â˜†
    ArrayBlockingQueue  â€” bounded, backed by array, single lock
    LinkedBlockingQueue â€” optionally bounded, two locks (head/tail)
    SynchronousQueue    â€” zero capacity, direct handoff only
    PriorityBlockingQueue â€” unbounded, natural/custom ordering
    DelayQueue          â€” elements available after delay expires
    LinkedTransferQueue â€” like SynchronousQueue but with queue backup
```

**Practice problems:**
- Build a thread-safe bounded cache using ReentrantReadWriteLock
- Build a connection pool using Semaphore
- Implement producer-consumer using BlockingQueue (should be trivial with BlockingQueue)
- Write a CompletableFuture pipeline: fetch user â†’ fetch orders â†’ compute total â†’ save to DB (async chain)
- Build ThreadPoolExecutor with bounded queue and CallerRunsPolicy, observe backpressure

---

### ğŸ”¬ Level 3 â€” Advanced Topics (Week 6-7)

```
1. ForkJoinPool and RecursiveTask/RecursiveAction     â˜…â˜…â˜…â˜…â˜†
   - Work-stealing: idle threads steal tasks from busy threads' queues
   - Best for: recursive divide-and-conquer (array sum, merge sort, tree traversal)
   - RecursiveTask<V>  â†’ compute() returns a value
   - RecursiveAction   â†’ compute() returns void
   - fork() + join() vs invokeAll()
   - ForkJoinPool.commonPool() â€” shared default pool (also used by parallel streams)
   - Danger: long blocking tasks in commonPool block parallel streams

2. Parallel Streams                                   â˜…â˜…â˜…â˜…â˜†
   - parallelStream() delegates to ForkJoinPool.commonPool()
   - When to use: CPU-bound, large data, stateless operations
   - When NOT to use: small data, I/O operations, shared mutable state
   - Use custom ForkJoinPool to isolate parallel stream from commonPool:
     ForkJoinPool myPool = new ForkJoinPool(4);
     myPool.submit(() -> list.parallelStream().map(...).collect(...)).get();

3. AbstractQueuedSynchronizer (AQS)                   â˜…â˜…â˜…â˜†â˜†
   - The backbone implementation of most locks and synchronizers
   - ReentrantLock, Semaphore, CountDownLatch all built on AQS
   - Core idea: integer state + FIFO queue of waiting threads
   - Exclusive mode (ReentrantLock) vs Shared mode (Semaphore, CountDownLatch)
   - For interview: understand the concept, not the implementation details
   - Know: tryAcquire / tryRelease / acquire / release

4. LongAdder and LongAccumulator                      â˜…â˜…â˜…â˜†â˜†
   - High-throughput alternatives to AtomicLong
   - Maintains multiple cells (one per contending thread) + base
   - sum() aggregates them â€” may be stale
   - Use when: high contention increments (metrics, counters)
   - AtomicLong better when: you need precise consistent reads

5. ThreadLocal advanced patterns                      â˜…â˜…â˜…â˜…â˜†
   - InheritableThreadLocal â€” child thread inherits parent's value
   - ThreadLocal in Spring: SecurityContextHolder, TransactionSynchronizationManager
   - Memory leak pattern in thread pools:
     Thread is reused â†’ ThreadLocal value persists across requests
     FIX: always threadLocal.remove() in finally or use request-scope beans

6. Thread Pool Sizing (the formula)                   â˜…â˜…â˜…â˜…â˜…
   CPU-bound:    threads = N (or N+1 to handle one page fault)
   I/O-bound:    threads = N Ã— (1 + W/C)  where W=wait time, C=compute time
   Mixed:        profile first, then tune

7. False Sharing (cache line problem)                 â˜…â˜…â˜…â˜†â˜†
   - CPU cache lines are 64 bytes
   - If two threads write to different variables on the SAME cache line
     â†’ each write invalidates the other's cache â†’ massive contention
   - Fix: padding (add dummy fields to push variables to different cache lines)
   - Java 8+: @Contended annotation (in jdk.internal.vm.annotation)
   - LongAdder uses this internally (why it beats AtomicLong at scale)

8. Java 21 Virtual Threads                            â˜…â˜…â˜…â˜…â˜…
   - Thread.ofVirtual().start(runnable)
   - Executors.newVirtualThreadPerTaskExecutor()
   - Cheap: millions of virtual threads vs thousands of platform threads
   - Blocking is fine: JVM parks virtual thread, not the platform thread
   - Do NOT pool virtual threads (defeats the purpose â€” they are cheap)
   - Pinning problem: synchronized blocks pin virtual thread to carrier thread
     â†’ prefer ReentrantLock over synchronized in virtual thread code
   - Structured Concurrency (preview): StructuredTaskScope â€” scope-based
     lifetime management for forked virtual threads

9. Memory Leaks in Concurrency                        â˜…â˜…â˜…â˜…â˜†
   - ThreadLocal not removed in thread pool
   - Listeners/callbacks registered but never deregistered
   - Tasks submitted to executor but executor never shut down
   - ConcurrentHashMap holding strong references to objects
   - Threads holding references to large objects preventing GC
```

---

### ğŸƒ Level 4 â€” Spring Boot Concurrency (Week 7-8)

```
1. @Async                                             â˜…â˜…â˜…â˜…â˜…
   - Add @EnableAsync to config class
   - Annotate method with @Async â†’ runs in separate thread
   - Default: SimpleAsyncTaskExecutor (creates new thread per call â€” dangerous!)
   - Always configure a ThreadPoolTaskExecutor bean
   - @Async methods MUST be in a different bean (Spring proxy limitation)
   - @Async on private or same-class methods = silently ignored
   - Return: void, Future<T>, CompletableFuture<T>, ListenableFuture<T>

   Example configuration:
   @Bean("taskExecutor")
   public Executor taskExecutor() {
       ThreadPoolTaskExecutor exec = new ThreadPoolTaskExecutor();
       exec.setCorePoolSize(5);
       exec.setMaxPoolSize(20);
       exec.setQueueCapacity(100);
       exec.setThreadNamePrefix("async-");
       exec.setRejectedExecutionHandler(new CallerRunsPolicy());
       exec.initialize();
       return exec;
   }

2. @Scheduled                                         â˜…â˜…â˜…â˜†â˜†
   - @EnableScheduling in config
   - fixedRate â€” run every N ms regardless of completion
   - fixedDelay â€” wait N ms AFTER last completion then run again
   - cron â€” standard cron expression
   - Default: single-threaded scheduler â€” tasks queue up if one is slow
   - Fix: configure ScheduledExecutorService or TaskScheduler bean

3. Spring Transaction Isolation Levels                â˜…â˜…â˜…â˜…â˜…
   (concurrency at database level â€” always asked in Spring interviews)
   - READ_UNCOMMITTED: dirty reads possible (fastest, least safe)
   - READ_COMMITTED:   no dirty reads, phantom/non-repeatable reads possible
   - REPEATABLE_READ:  no dirty/non-repeatable reads, phantom reads possible
   - SERIALIZABLE:     fully isolated, slowest

   - Default in Spring: follows database default (usually READ_COMMITTED)
   - Concurrency problems:
     Dirty Read:           read uncommitted data from another transaction
     Non-Repeatable Read:  same query returns different rows in same transaction
     Phantom Read:         new rows appear between two reads in same transaction

4. Spring's TaskExecutor / ThreadPoolTaskExecutor     â˜…â˜…â˜…â˜…â˜†
   - Spring's wrapper around java.util.concurrent.ThreadPoolExecutor
   - ThreadPoolTaskExecutor: most important, wraps ThreadPoolExecutor
   - ConcurrentTaskExecutor: wraps any java.util.concurrent.Executor
   - SimpleAsyncTaskExecutor: creates new thread per task (only for testing)

5. HikariCP Connection Pool                           â˜…â˜…â˜…â˜…â˜†
   - Default connection pool in Spring Boot 2+
   - maximumPoolSize: default 10 (tune based on DB + application threads)
   - connectionTimeout: how long to wait for connection from pool
   - idleTimeout: how long idle connections are kept
   - maximumPoolSize of HikariCP should roughly match ThreadPoolExecutor size
   - Too few DB connections = thread pool threads blocked waiting for connection
   - Too many DB connections = DB overwhelmed

6. Spring WebFlux / Reactive                          â˜…â˜…â˜…â˜†â˜†
   - Project Reactor (Mono / Flux)
   - Non-blocking I/O on Netty (event loop, not thread-per-request)
   - flatMap = async composition, map = sync transformation
   - subscribeOn â†’ which thread subscribes (starts execution)
   - publishOn â†’ which thread publishes (downstream operators)
   - Schedulers.boundedElastic() â€” for blocking code in reactive pipeline
   - Do NOT use in same app as Spring MVC without careful threading config

7. Cache Concurrency (Redis / Caffeine)               â˜…â˜…â˜…â˜†â˜†
   - Cache-aside pattern thread safety
   - Double-checked locking for cache population
   - Redis SETNX / Lua scripts for distributed locking
   - @Cacheable thread safety in Spring (uses ConcurrentMap internally)
   - Caffeine: compute() is atomic â€” safe for cache population
```

---

### ğŸ† Level 5 â€” Interview Ready (Week 9-12)

```
CLASSIC CODING PROBLEMS every Java concurrency interview covers:

1. Thread-safe Singleton (Double-Checked Locking)
   - Why volatile is required on the instance field
   - What breaks without it (partial initialization visible to other threads)

2. Producer-Consumer
   - With wait/notify
   - With BlockingQueue (trivially easy, show you know both)

3. Print numbers alternately from two threads
   - Thread 1 prints odd, Thread 2 prints even, in order 1 2 3 4...
   - Uses wait/notify, shows monitor understanding

4. Dining Philosophers
   - Classic deadlock scenario
   - Solutions: lock ordering, tryLock with timeout, one left-handed philosopher

5. Read-Write problem
   - Multiple readers, one writer
   - Implement with ReadWriteLock
   - Or with wait/notify from scratch (tests deeper understanding)

6. Implement a thread-safe blocking queue from scratch
   - Using ReentrantLock + 2 Conditions (notFull, notEmpty)
   - Very popular senior interview question

7. Rate Limiter
   - Using Semaphore
   - Fixed window vs sliding window

8. Connection Pool
   - Using Semaphore + ConcurrentLinkedQueue

9. Future/CompletableFuture chains
   - Chain 3 async service calls
   - Handle errors with exceptionally
   - Run two in parallel, combine with thenCombine

10. Deadlock detection in a thread dump
    - Given a jstack output, identify deadlock
    - Which thread holds which lock


SYSTEM DESIGN WITH CONCURRENCY (senior SDE level):

- Design a thread-safe LRU Cache (LinkedHashMap + ReentrantReadWriteLock)
- Design a rate limiter service (Semaphore / token bucket)
- Design an async notification system (@Async + queue + retry)
- Design a task scheduler (ScheduledExecutorService / Quartz)
- Design a parallel bulk data processor (ForkJoinPool / parallel streams)
- Explain how to handle concurrency in a microservices environment
  (optimistic locking, distributed locks via Redis, event sourcing)
```

---

## Study Resources (Curated)

```
BOOKS (in order of reading):
  1. Java Concurrency in Practice â€” Brian Goetz et al.
     (THE bible â€” read chapters 1-5 and 12-16 at minimum)
  2. The Art of Multiprocessor Programming â€” Herlihy & Shavit
     (for senior/FAANG â€” lock-free algorithms, AQS depth)

PRACTICE:
  1. Write every synchronizer from scratch (CountDownLatch, Semaphore,
     BlockingQueue) using only ReentrantLock + Condition
  2. LeetCode: "Print in Order", "Print FooBar Alternately",
     "Print Zero Even Odd", "Building H2O", "The Dining Philosophers"
  3. Read JDK source: ReentrantLock, CountDownLatch, ConcurrentHashMap
     (critical parts are ~50 lines â€” very readable)

TOOLS:
  jstack   â€” take thread dump, spot deadlocks
  jconsole â€” GUI thread monitoring, deadlock detection
  VisualVM â€” thread profiling, CPU usage per thread
  IntelliJ Thread Concurrency plugin â€” annotates @GuardedBy etc.
```

---

## The Priority Matrix (what to study first if time is short)

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ABSOLUTE MUST (every interview, every company)                   â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â•‘
â•‘  Thread lifecycle Â· synchronized Â· volatile Â· wait/notify/join    â•‘
â•‘  ExecutorService Â· ThreadPoolExecutor Â· Future Â· Callable         â•‘
â•‘  CompletableFuture basics Â· ConcurrentHashMap Â· AtomicInteger     â•‘
â•‘  CountDownLatch Â· Semaphore Â· ReentrantLock Â· Deadlock            â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  HIGHLY LIKELY (mid-senior interviews)                            â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â•‘
â•‘  ThreadLocal Â· BlockingQueue Â· ReadWriteLock Â· CyclicBarrier      â•‘
â•‘  ForkJoinPool Â· Parallel Streams Â· Spring @Async Â· LongAdder      â•‘
â•‘  Thread pool sizing Â· Transaction isolation Â· HikariCP            â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  GOOD TO KNOW (senior / FAANG)                                    â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â•‘
â•‘  AQS internals Â· StampedLock Â· Phaser Â· Exchanger                 â•‘
â•‘  False sharing Â· VarHandle Â· Virtual Threads (Java 21)            â•‘
â•‘  Structured Concurrency Â· Reactive (WebFlux) Â· Lock-free algos   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

The entire journey can be summarized in one sentence:

> **Start from WHY things break (JMM, visibility, atomicity) â†’ learn the primitives (Thread, synchronized, wait/notify) â†’ master the framework (ExecutorService, CompletableFuture, collections) â†’ apply in Spring Boot â†’ practice classic interview problems â€” and you will be ready.**