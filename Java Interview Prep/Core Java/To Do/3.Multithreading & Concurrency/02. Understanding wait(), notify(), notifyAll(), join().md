# The Story of Mario's Restaurant ‚Äî Understanding wait(), notify(), notifyAll(), join()

---

## üè™ The Setting ‚Äî Mario's Italian Restaurant

It is Friday night at Mario's Italian restaurant. The kitchen and dining floor are separated by a single counter called **"The Pass"** ‚Äî the window where Chef Mario places finished dishes for waiters to pick up.

**The Cast:**
- üßë‚Äçüç≥ **Chef Mario** ‚Äî cooks and places dishes on The Pass *(Producer Thread)*
- üßë‚ÄçüçΩÔ∏è **Waiter Luigi** ‚Äî picks up dishes, serves tables *(Consumer Thread 1)*
- üë©‚ÄçüçΩÔ∏è **Waiter Peach** ‚Äî picks up dishes, serves tables *(Consumer Thread 2)*
- üëî **Manager Toad** ‚Äî coordinates everything, closes restaurant *(Main Thread)*

**The Pass** in the real world maps to Java as:
```
The Pass Object      = the shared monitor object (synchronized on)
The Physical Counter = the intrinsic lock (only ONE person at counter at a time)
Entry Queue          = threads BLOCKED trying to acquire the lock (entry set)
Waiting Room chairs  = threads that CALLED wait() (wait set)
```

This is the visual picture of the monitor:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  THE PASS (Monitor)              ‚îÇ
‚îÇ                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Entry Queue ‚îÇ        ‚îÇ   Waiting Room       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ (Entry Set) ‚îÇ        ‚îÇ   (Wait Set)         ‚îÇ ‚îÇ
‚îÇ  ‚îÇ             ‚îÇ        ‚îÇ                      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ Luigi ‚îÄ‚îÄ‚îê   ‚îÇ        ‚îÇ  Peach (called wait) ‚îÇ ‚îÇ
‚îÇ  ‚îÇ         ‚ñº   ‚îÇ        ‚îÇ  Toad  (called wait) ‚îÇ ‚îÇ
‚îÇ  ‚îÇ     [LOCK]‚óÑ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ notify() moves   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ      ‚îÄ‚îÄ‚ñ∫    ‚îÇ        ‚îÇ     thread here      ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üö´ The Problem First ‚Äî Life Without wait()/notify()

Friday night. Luigi walks up to The Pass to pick up his order. But the pasta isn't ready yet.

**Luigi's first instinct (the WRONG approach):** Stand at the counter and keep checking every second.

```java
// The WRONG way ‚Äî Busy Waiting
public class ThePass_BrokenVersion {
    private String dish = null;

    // Luigi calls this - synchronized means Luigi holds the lock on ThePass
    public synchronized String pickUpDish(String waiterName) {
        // Luigi is AT the counter, HOLDING the lock
        while (dish == null) {
            // Luigi keeps checking... checking... checking...
            // HE IS HOLDING THE LOCK THE ENTIRE TIME
            // Chef Mario CANNOT put food (needs the same lock to call putDish)
            // Luigi waits for food that Chef can NEVER deliver
            // = DEADLOCK üîí
        }
        return dish;
    }

    public synchronized void putDish(String dishName) {
        // Chef CANNOT enter ‚Äî Luigi is holding the lock!
        // This method NEVER gets called ‚Üí Luigi waits forever
        this.dish = dishName;
    }
}
```

```
What happens:
  Luigi enters ‚Üí acquires lock ‚Üí dish == null ‚Üí loops
  Chef arrives ‚Üí BLOCKED (Luigi has the lock)
  Luigi keeps looping ‚Üí will NEVER see dish arrive
  RESULT: Deadlock + 100% CPU usage (spinning for nothing)
```

**The restaurant is broken.** We need a way for Luigi to say:
> *"Food isn't ready? Fine ‚Äî I'll step away from the counter, release it so Chef can use it, and someone call me when it's ready."*

That is exactly what `wait()` does.

---

## üõéÔ∏è Act 1: wait() ‚Äî "Step Back, You'll Be Called"

**The Story:**

Luigi comes to The Pass. Pasta isn't ready. Instead of hogging the counter, he:
1. **Steps away from the counter** (releases the lock)
2. **Walks to the Waiting Room** (thread enters the wait set, gets suspended)
3. **Sits down and does nothing** (thread is parked ‚Äî no CPU usage)
4. **Waits to be tapped on the shoulder** (waits for notify())

Chef Mario can now freely access The Pass.

```java
public class ThePass {
    private String dish = null;   // the current dish on the pass

    /**
     * WAITER calls this to pick up food.
     * If no food ‚Üí waiter releases lock and waits in Waiting Room.
     */
    public synchronized String pickUp(String waiterName) throws InterruptedException {

        // ALWAYS 'while', NEVER 'if' ‚Äî explained in depth later
        while (dish == null) {

            System.out.println(waiterName + ": Nothing on pass yet. Stepping to waiting room...");

            //  ‚îå‚îÄ wait() does THREE things atomically ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            //  ‚îÇ  1. RELEASES the lock on 'this' (ThePass object)               ‚îÇ
            //  ‚îÇ  2. SUSPENDS this thread (moves it into the wait set)          ‚îÇ
            //  ‚îÇ  3. When notified later: RE-ACQUIRES the lock, then returns    ‚îÇ
            //  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            wait();

            // Thread resumes HERE after being notified AND re-acquiring the lock
            // The while loop then re-checks the condition
            System.out.println(waiterName + ": I was called back! Checking the pass...");
        }

        // Condition is true ‚Äî pick up the dish
        String pickedDish = dish;
        dish = null;  // clear the pass for next dish
        System.out.println(waiterName + ": Picked up [" + pickedDish + "] ‚úì");
        return pickedDish;
    }
}
```

**Visualizing what wait() does step by step:**

```
1. Luigi calls pickUp() ‚Üí acquires lock on ThePass
2. dish == null ‚Üí Luigi calls wait()

   wait() atomically:
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ  a) Luigi releases the lock on ThePass         ‚îÇ
   ‚îÇ  b) Luigi moves to the Wait Set (waiting room) ‚îÇ
   ‚îÇ  c) Luigi's thread is SUSPENDED (0% CPU)       ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

3. Chef can now acquire the lock ‚Üí puts dish ‚Üí calls notify()

   notify() moves Luigi from Wait Set ‚Üí Entry Set
   Luigi tries to re-acquire lock
   Luigi re-acquires lock ‚Üí wait() returns
   Luigi re-checks while condition ‚Üí dish != null ‚Üí picks it up
```

---

## üîî Act 2: notify() ‚Äî "One of You, Come Check"

**The Story:**

Chef Mario finishes the pasta. He rings a small bell on the counter (`notify()`). This wakes up **exactly ONE** waiter from the Waiting Room ‚Äî they get up, walk to the Entry Queue, and wait their turn at the counter. Which waiter? Chef has no say ‚Äî it's whoever the JVM picks (not necessarily Luigi, not necessarily who's been waiting longest).

```java
public class ThePass {
    private String dish = null;

    /**
     * CHEF calls this to put food on the pass.
     * Signals ONE waiting waiter to come check.
     */
    public synchronized void putDish(String dishName) throws InterruptedException {

        // Wait if a dish is already sitting on the pass (not yet picked up)
        while (dish != null) {
            System.out.println("Chef: Pass is occupied by [" + dish + "]. Waiting...");
            wait(); // Chef also waits if pass is full!
        }

        dish = dishName;
        System.out.println("Chef: Placed [" + dishName + "] on pass üçù");

        //  ‚îå‚îÄ notify() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        //  ‚îÇ  1. Picks ONE thread from the wait set (arbitrary JVM choice)     ‚îÇ
        //  ‚îÇ  2. Moves that thread to the entry set (ready to compete)         ‚îÇ
        //  ‚îÇ  3. That thread STILL doesn't run ‚Äî it must re-acquire the lock   ‚îÇ
        //  ‚îÇ  4. Chef still holds the lock ‚Äî chef finishes synchronized block  ‚îÇ
        //  ‚îÇ     THEN releases the lock ‚Äî THEN the notified thread can run     ‚îÇ
        //  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        notify();

        System.out.println("Chef: Bell rung. One waiter notified.");
        // Chef exits synchronized block ‚Üí releases lock ‚Üí notified waiter can proceed
    }

    public synchronized String pickUp(String waiterName) throws InterruptedException {
        while (dish == null) {
            System.out.println(waiterName + ": Not ready. Waiting...");
            wait();
        }
        String pickedDish = dish;
        dish = null;
        notify(); // tell chef "pass is clear, next dish please"
        System.out.println(waiterName + ": Got [" + pickedDish + "] ‚úì");
        return pickedDish;
    }
}
```

**Demo ‚Äî Chef + One Waiter:**

```java
public class RestaurantDemo_NotifyOne {
    public static void main(String[] args) throws InterruptedException {
        ThePass pass = new ThePass();

        // Luigi starts first ‚Äî will immediately wait (no dish yet)
        Thread luigi = new Thread(() -> {
            try {
                pass.pickUp("Luigi");
            } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        }, "Luigi");

        Thread chef = new Thread(() -> {
            try {
                Thread.sleep(1000); // simulate cooking time
                pass.putDish("Carbonara");
            } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        }, "Chef Mario");

        luigi.start();
        chef.start();

        luigi.join();
        chef.join();
    }
}
```

**Output:**
```
Luigi  : Nothing on pass yet. Stepping to waiting room...    ‚Üê wait() called
[1 second passes... Chef is cooking]
Chef   : Placed [Carbonara] on pass üçù
Chef   : Bell rung. One waiter notified.                     ‚Üê notify() called
Luigi  : I was called back! Checking the pass...             ‚Üê wait() returned
Luigi  : Got [Carbonara] ‚úì
```

**Critical detail about notify():**

```
notify() does NOT immediately give the lock to the notified thread.

Timeline:
  Chef:  [holding lock] ‚Üí places dish ‚Üí calls notify() ‚Üí STILL holds lock
                        ‚Üí finishes synchronized block ‚Üí releases lock
  Luigi: [in wait set] ‚Üí moved to entry set by notify()
                       ‚Üí waits for Chef to release lock
                       ‚Üí acquires lock ‚Üí wait() returns ‚Üí picks up dish

The notified thread competes for the lock AFTER the notifier finishes.
```

---

## üì£ Act 3: notifyAll() ‚Äî "Everyone, Come Check!"

**The Story:**

Now it's a busy Friday night. Both Luigi AND Peach are in the Waiting Room. Chef Mario finishes a big batch and yells **"Orders Up!"** (`notifyAll()`). BOTH Luigi and Peach jump up from their seats, walk to the Entry Queue, and compete for the counter. Only ONE gets the lock at a time. The one who gets it first checks the pass ‚Äî if their dish is there they take it; if not, they go back to the Waiting Room. Then the second one gets the lock and checks.

```java
public class ThePass_NotifyAll {
    private String dish = null;

    public synchronized void putDishAndNotifyAll(String dishName) throws InterruptedException {
        while (dish != null) {
            wait();
        }
        dish = dishName;
        System.out.println("Chef: Placed [" + dishName + "] on pass üçù");

        //  ‚îå‚îÄ notifyAll() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        //  ‚îÇ  Moves ALL threads from wait set ‚Üí entry set                      ‚îÇ
        //  ‚îÇ  All of them compete for the lock                                 ‚îÇ
        //  ‚îÇ  Each one, when it gets the lock, re-checks the while condition   ‚îÇ
        //  ‚îÇ  Only the one whose condition is met proceeds                     ‚îÇ
        //  ‚îÇ  Others go back to wait set                                       ‚îÇ
        //  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        notifyAll();

        System.out.println("Chef: Loudspeaker used ‚Äî ALL waiters notified!");
    }

    public synchronized String pickUp(String waiterName) throws InterruptedException {
        while (dish == null) {
            System.out.println(waiterName + ": Waiting in room...");
            wait();
        }
        String pickedDish = dish;
        dish = null;
        notify(); // signal chef that pass is clear
        System.out.println(waiterName + ": Got [" + pickedDish + "] ‚úì");
        return pickedDish;
    }
}
```

**Demo ‚Äî Two Waiters, One Dish:**

```java
public class RestaurantDemo_NotifyAll {
    public static void main(String[] args) throws InterruptedException {
        ThePass_NotifyAll pass = new ThePass_NotifyAll();

        Thread luigi = new Thread(() -> {
            try { pass.pickUp("Luigi"); }
            catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        }, "Luigi");

        Thread peach = new Thread(() -> {
            try { pass.pickUp("Peach"); }
            catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        }, "Peach");

        luigi.start();
        peach.start();
        Thread.sleep(500); // let both start waiting

        // Chef makes ONE dish and calls notifyAll()
        Thread chef = new Thread(() -> {
            try {
                Thread.sleep(500);
                pass.putDishAndNotifyAll("Carbonara");
                Thread.sleep(500);
                pass.putDishAndNotifyAll("Margherita"); // second dish for second waiter
            } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        }, "Chef Mario");

        chef.start();
        luigi.join(); peach.join(); chef.join();
    }
}
```

**Output:**
```
Luigi: Waiting in room...                         ‚Üê both in wait set
Peach: Waiting in room...
Chef : Placed [Carbonara] on pass üçù
Chef : Loudspeaker ‚Äî ALL waiters notified!        ‚Üê notifyAll() ‚Äî both move to entry set

Luigi: I was called back! Checking pass...        ‚Üê Luigi gets lock first
Luigi: Got [Carbonara] ‚úì                          ‚Üê Luigi takes it

Peach: I was called back! Checking pass...        ‚Üê Peach gets lock next
Peach: dish == null ‚Üí back to waiting room        ‚Üê while loop ‚Üí back to wait()

Chef : Placed [Margherita] on pass üçù
Chef : Loudspeaker ‚Äî ALL waiters notified!
Peach: I was called back! Checking pass...
Peach: Got [Margherita] ‚úì
```

---

## ‚ö†Ô∏è The GOLDEN RULE ‚Äî Always `while`, Never `if` ‚Äî Two Reasons

This is the most important rule when using wait/notify. Let's see exactly what breaks with `if`.

### Reason 1: Spurious Wakeups

```
The JVM specification explicitly states:
"A thread can wake up from wait() without being notified,
 interrupted, or timing out." ‚Äî this is called a SPURIOUS WAKEUP.

It is rare but LEGAL. Hardware/OS can cause it.
If you use 'if', you proceed with stale state.
If you use 'while', you re-check and go back to waiting.
```

### Reason 2: Multiple Waiters on Same Condition (notifyAll scenario)

```java
public class WhyWhileNotIf {

    private String dish = null;

    //  ‚ùå WRONG ‚Äî using 'if'
    public synchronized String pickUpWrong(String waiterName) throws InterruptedException {

        if (dish == null) {          // Luigi checks: null ‚Üí enters if block
            wait();                  // Luigi waits...
                                     // Chef puts Carbonara, calls notifyAll()
                                     // BOTH Luigi AND Peach wake up
        }
        // Luigi gets lock first, dish = "Carbonara", Luigi takes it, dish = null
        // NOW Peach gets lock ‚Äî Peach is past the 'if' block (doesn't re-check!)
        // dish is NULL but Peach tries to use it
        String pickedDish = dish;    // Peach: dish = null  üí•
        dish = null;
        return pickedDish;           // Peach returns null ‚Äî WRONG!
    }

    //  ‚úÖ CORRECT ‚Äî using 'while'
    public synchronized String pickUpCorrect(String waiterName) throws InterruptedException {

        while (dish == null) {       // Luigi checks: null ‚Üí waits
            wait();                  // notifyAll() wakes both Luigi and Peach
        }
        // Luigi gets lock first ‚Üí dish != null ‚Üí exits while ‚Üí takes Carbonara ‚Üí dish = null
        // Peach gets lock ‚Üí while checks dish == null ‚Üí TRUE ‚Üí Peach goes back to wait()
        // Peach waits for next notify when a new dish is placed

        String pickedDish = dish;    // Safe ‚Äî condition was verified
        dish = null;
        return pickedDish;           // Correct ‚úì
    }
}
```

```
The simple rule to engrave in memory:

    Every wait() call MUST be inside a while loop
    that checks the exact condition you are waiting for.

    while (<condition not met>) {
        wait();
    }
    // Now proceed safely ‚Äî condition is guaranteed to be met here
```

---

## ‚è≥ Act 3b: wait(timeout) ‚Äî "I'll Wait, But Not Forever"

**The Story:**

Peach is waiting for a dessert order. But she's a professional ‚Äî she won't wait indefinitely. After 5 minutes she'll proactively check in with the kitchen herself.

```java
public synchronized String pickUpWithTimeout(String waiterName, long timeoutMs)
        throws InterruptedException {

    long deadline = System.currentTimeMillis() + timeoutMs;

    while (dish == null) {
        long remaining = deadline - System.currentTimeMillis();

        if (remaining <= 0) {
            // Timeout expired ‚Äî give up waiting
            System.out.println(waiterName + ": Waited too long. Going to check manually.");
            return null; // caller handles the null (retry, fail, etc.)
        }

        System.out.println(waiterName + ": Waiting up to " + remaining + "ms...");

        //  wait(timeout):
        //  Same as wait() BUT:
        //  - also wakes up after 'remaining' milliseconds automatically
        //  - thread still needs to re-acquire the lock after waking
        //  - you CANNOT tell if you were notified or timed out from the return value
        //    ‚Üí that is why you must check the condition yourself after returning
        wait(remaining);

        // You don't know if notified or timed out ‚Äî while loop handles both
    }

    String pickedDish = dish;
    dish = null;
    System.out.println(waiterName + ": Got [" + pickedDish + "] ‚úì");
    return pickedDish;
}
```

```
Three overloads of wait():

  wait()                    ‚Üí wait indefinitely until notify/interrupt
  wait(long millis)         ‚Üí wait at most 'millis' milliseconds
  wait(long millis, int ns) ‚Üí wait at most 'millis' ms + 'ns' nanoseconds

  All three:
  - Must be called inside synchronized block
  - Must be inside a while loop
  - Release the lock while waiting
  - Re-acquire lock before returning
```

---

## ü§ù Act 4: join() ‚Äî "I Won't Move Until You're Completely Done"

**The Story:**

At the end of the night, Manager Toad needs to count all the evening's tips and write the closing report. But he **cannot start counting** until every single waiter has finished serving their last table and come back.

Toad doesn't know how long each waiter will take. He simply **waits at his desk** (`join()`) for Luigi ‚Äî until Luigi completely finishes and clocks out. Then he waits for Peach. Only after everyone has fully finished does Toad start the closing report.

```join()` is different from `wait()`:
- `wait()` ‚Üí thread waits for a CONDITION to change on a shared object
- `join()` ‚Üí one thread waits for ANOTHER THREAD to completely finish (die)

```java
public class RestaurantClosing {

    static void serveLastTable(String name, int minutes) throws InterruptedException {
        System.out.println(name + ": Serving last table...");
        Thread.sleep(minutes * 100L); // simulate time
        System.out.println(name + ": Done! Clocking out.");
        // Thread naturally finishes here ‚Äî it "dies"
    }

    public static void main(String[] args) throws InterruptedException {

        Thread luigi = new Thread(() -> {
            try { serveLastTable("Luigi", 20); }
            catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        }, "Luigi");

        Thread peach = new Thread(() -> {
            try { serveLastTable("Peach", 35); }
            catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        }, "Peach");

        Thread mario = new Thread(() -> {
            try { serveLastTable("Chef Mario", 10); }
            catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        }, "Mario");

        System.out.println("Toad: Staff wrapping up. I'll wait for everyone.");

        luigi.start();
        peach.start();
        mario.start();

        // Toad (main thread) waits here ‚Äî doing NOTHING until Luigi fully finishes
        luigi.join();   // blocks main thread until Luigi's thread state = TERMINATED
        System.out.println("Toad: Luigi is done.");

        peach.join();   // blocks main thread until Peach's thread state = TERMINATED
        System.out.println("Toad: Peach is done.");

        mario.join();   // blocks main thread until Mario's thread state = TERMINATED
        System.out.println("Toad: Chef Mario is done.");

        // Only NOW does Toad start the closing report
        System.out.println("Toad: Everyone done! Writing closing report. üìã");
    }
}
```

**Output:**
```
Toad       : Staff wrapping up. I'll wait for everyone.
Chef Mario : Serving last table...
Luigi      : Serving last table...
Peach      : Serving last table...
Chef Mario : Done! Clocking out.    ‚Üê Mario finishes first, but Toad is join()ing Luigi
Luigi      : Done! Clocking out.    ‚Üê Luigi finishes
Toad       : Luigi is done.         ‚Üê luigi.join() returns
Peach      : Done! Clocking out.    ‚Üê Peach finishes
Toad       : Peach is done.         ‚Üê peach.join() returns
Toad       : Chef Mario is done.    ‚Üê mario.join() returns (Mario was long done but now checked)
Toad       : Everyone done! Writing closing report. üìã
```

**join() with timeout ‚Äî "I'll wait, but only so long":**

```java
// join() variants
luigi.join();                  // wait FOREVER until Luigi's thread dies
luigi.join(5000);              // wait at most 5000 milliseconds
luigi.join(5000, 500);         // wait at most 5000ms + 500ns

// How to check if join() timed out vs thread actually finished:
luigi.join(3000);              // wait max 3 seconds
if (luigi.isAlive()) {
    System.out.println("Luigi is STILL running after 3s ‚Äî moving on without him");
} else {
    System.out.println("Luigi finished within 3s");
}
```

**How join() works internally ‚Äî it uses wait() under the hood!**

```java
// Simplified version of Thread.join() from JDK source
// (Thread IS the object being synchronized on!)
public final synchronized void join(long millis) throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;

    if (millis == 0) {
        while (isAlive()) {
            wait(0); // waits on the Thread OBJECT's own monitor
                     // when the thread terminates, JVM internally calls
                     // this.notifyAll() on the Thread object
                     // ‚Üí all join()-ers wake up
        }
    } else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay <= 0) break;
            wait(delay); // same wait() you already know!
            now = System.currentTimeMillis() - base;
        }
    }
}
// When a thread terminates: JVM automatically calls notifyAll()
// on that Thread object ‚Äî waking everyone who called join() on it
```

```
The beautiful insight:

  join() IS wait/notify under the hood.
  
  Thread Toad calls luigi.join()
  ‚Üí Toad calls wait() on the Luigi Thread object
  ‚Üí When Luigi's thread terminates, JVM calls luigi.notifyAll()
  ‚Üí Toad wakes up from wait(), checks isAlive() == false, returns
  
  Everything in Java concurrency ultimately traces back to
  the fundamental wait/notify mechanism.
```

---

## üé¨ The Full Restaurant Simulation ‚Äî Everything Together

```java
import java.util.concurrent.ThreadLocalRandom;

/**
 * Complete simulation showing:
 * - wait()        : waiters wait when pass is empty
 * - notify()      : chef signals one waiter per dish
 * - notifyAll()   : used when multiple conditions possible
 * - join()        : manager waits for all staff
 * - while loop    : correct condition re-checking
 * - wait(timeout) : waiter gives up after N ms
 */
public class MarioRestaurant {

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // THE PASS ‚Äî the shared monitor object
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    static class ThePass {
        private String dish = null;
        private boolean restaurantOpen = true;

        /**
         * Chef puts a dish on the pass and notifies ONE waiter.
         */
        public synchronized void putDish(String dishName) throws InterruptedException {
            // If pass is occupied, Chef waits
            while (dish != null && restaurantOpen) {
                System.out.printf("[Chef]   Pass occupied [%s]. Waiting...%n", dish);
                wait();
            }
            if (!restaurantOpen) return;

            dish = dishName;
            System.out.printf("[Chef]   üçù Placed [%s] on pass. Ringing bell...%n", dishName);
            notify(); // ONE waiter woken up
        }

        /**
         * Waiter picks up a dish.
         * Waits up to timeoutMs ‚Äî returns null if timed out.
         */
        public synchronized String pickUp(String waiterName, long timeoutMs)
                throws InterruptedException {

            long deadline = System.currentTimeMillis() + timeoutMs;

            // GOLDEN RULE: always while, never if
            while (dish == null && restaurantOpen) {
                long remaining = deadline - System.currentTimeMillis();
                if (remaining <= 0) {
                    System.out.printf("[%-6s] Gave up waiting. Going to check with kitchen.%n",
                            waiterName);
                    return null; // timed out
                }
                System.out.printf("[%-6s] Nothing on pass. Stepping to waiting room...%n",
                        waiterName);
                wait(remaining); // wait(timeout) ‚Äî release lock, wait up to 'remaining' ms
                System.out.printf("[%-6s] Was notified or timed out. Re-checking pass...%n",
                        waiterName);
            }

            if (dish == null) return null; // restaurant closed

            String pickedDish = dish;
            dish = null;
            System.out.printf("[%-6s] ‚úì Picked up [%s]%n", waiterName, pickedDish);
            notify(); // tell chef pass is clear for next dish
            return pickedDish;
        }

        /**
         * Close the restaurant ‚Äî wake everyone still waiting.
         */
        public synchronized void closeRestaurant() {
            restaurantOpen = false;
            System.out.println("[Mgr]    üîê Restaurant closing ‚Äî waking all waiting staff.");
            notifyAll(); // wake EVERYONE ‚Äî they'll see restaurantOpen == false and exit
        }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // CHEF MARIO ‚Äî Producer Thread
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    static class ChefMario implements Runnable {
        private final ThePass pass;
        private final String[] menu = {"Carbonara", "Margherita", "Tiramisu",
                                       "Lasagna",   "Risotto",   "Panna Cotta"};

        ChefMario(ThePass pass) { this.pass = pass; }

        @Override
        public void run() {
            try {
                for (String dish : menu) {
                    int cookTime = ThreadLocalRandom.current().nextInt(300, 800);
                    System.out.printf("[Chef]   Cooking [%s] for %dms...%n", dish, cookTime);
                    Thread.sleep(cookTime);      // simulate cooking
                    pass.putDish(dish);          // place on pass, notify one waiter
                }
                System.out.println("[Chef]   All dishes done for tonight. üéâ");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // WAITER ‚Äî Consumer Thread (Luigi or Peach)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    static class Waiter implements Runnable {
        private final ThePass pass;
        private final String  name;
        private int           dishesServed = 0;

        Waiter(ThePass pass, String name) {
            this.pass = pass;
            this.name = name;
        }

        @Override
        public void run() {
            try {
                while (true) {
                    // Wait up to 3 seconds for a dish before checking in
                    String dish = pass.pickUp(name, 3000);

                    if (dish == null && !pass.restaurantOpen) break; // closed

                    if (dish != null) {
                        int serveTime = ThreadLocalRandom.current().nextInt(100, 400);
                        Thread.sleep(serveTime); // simulate serving
                        dishesServed++;
                        System.out.printf("[%-6s] Served [%s] to table. Total: %d%n",
                                name, dish, dishesServed);
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.printf("[%-6s] Clocking out. Served %d dishes tonight.%n",
                    name, dishesServed);
        }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // MAIN ‚Äî Manager Toad
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Mario's Restaurant ‚Äî Friday Night Service ===\n");

        ThePass  pass  = new ThePass();
        Waiter   luigi = new Waiter(pass, "Luigi");
        Waiter   peach = new Waiter(pass, "Peach");
        ChefMario chef = new ChefMario(pass);

        Thread chefThread  = new Thread(chef,  "Chef Mario");
        Thread luigiThread = new Thread(luigi, "Luigi");
        Thread peachThread = new Thread(peach, "Peach");

        System.out.println("[Mgr]    Opening restaurant. Staff starting...\n");
        luigiThread.start();
        peachThread.start();
        chefThread.start();

        // Manager waits for Chef to finish all dishes
        chefThread.join();                  // ‚Üê join(): main thread blocks until chef done
        System.out.println("\n[Mgr]    Chef is done. Closing restaurant shortly...");

        Thread.sleep(500); // brief pause to let last dish be picked up

        pass.closeRestaurant();             // ‚Üê notifyAll(): wake all waiting staff

        // Manager waits for ALL waiters to finish
        luigiThread.join();                 // ‚Üê join(): wait for Luigi to clock out
        peachThread.join();                 // ‚Üê join(): wait for Peach to clock out

        System.out.println("\n[Mgr]    Everyone clocked out.");
        System.out.printf("[Mgr]    Luigi served: %d | Peach served: %d%n",
                luigi.dishesServed, peach.dishesServed);
        System.out.println("[Mgr]    üìã Writing closing report. Good night!");
    }
}
```

**Sample output:**
```
=== Mario's Restaurant ‚Äî Friday Night Service ===

[Mgr]    Opening restaurant. Staff starting...

[Luigi ] Nothing on pass. Stepping to waiting room...    ‚Üê wait()
[Peach ] Nothing on pass. Stepping to waiting room...    ‚Üê wait()
[Chef]   Cooking [Carbonara] for 432ms...
[Chef]   üçù Placed [Carbonara] on pass. Ringing bell... ‚Üê notify() ‚Äî ONE waiter wakes
[Luigi ] Was notified. Re-checking pass...
[Luigi ] ‚úì Picked up [Carbonara]
[Peach ] Timed out. Re-checking pass...                  ‚Üê wait(3000) expired
[Peach ] Nothing on pass. Stepping to waiting room...    ‚Üê while loop ‚Üí wait() again
[Chef]   Cooking [Margherita] for 561ms...
[Luigi ] Served [Carbonara] to table. Total: 1
[Chef]   üçù Placed [Margherita] on pass. Ringing bell...
[Peach ] Was notified. Re-checking pass...
[Peach ] ‚úì Picked up [Margherita]
... [more dishes] ...
[Chef]   All dishes done for tonight. üéâ

[Mgr]    Chef is done. Closing restaurant shortly...
[Mgr]    üîê Restaurant closing ‚Äî waking all waiting staff. ‚Üê notifyAll()
[Luigi ] Clocking out. Served 3 dishes tonight.
[Peach ] Clocking out. Served 3 dishes tonight.

[Mgr]    Everyone clocked out.
[Mgr]    Luigi served: 3 | Peach served: 3
[Mgr]    üìã Writing closing report. Good night!
```

---

## üìå The One-Page Mental Map

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  WHAT EACH METHOD DOES                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ wait()       ‚îÇ "I need something. Until it arrives,              ‚îÇ
‚îÇ              ‚îÇ  I'll release the lock and park myself."          ‚îÇ
‚îÇ              ‚îÇ  ‚Üí releases lock + suspends thread                ‚îÇ
‚îÇ              ‚îÇ  ‚Üí must be inside synchronized                    ‚îÇ
‚îÇ              ‚îÇ  ‚Üí must be inside while loop                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ notify()     ‚îÇ "Hey, ONE of you waiting ‚Äî come check."           ‚îÇ
‚îÇ              ‚îÇ  ‚Üí wakes ONE thread from wait set                 ‚îÇ
‚îÇ              ‚îÇ  ‚Üí JVM chooses which one (not FIFO)               ‚îÇ
‚îÇ              ‚îÇ  ‚Üí must be inside synchronized                    ‚îÇ
‚îÇ              ‚îÇ  ‚Üí notified thread still waits for lock           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ notifyAll()  ‚îÇ "Hey ALL of you waiting ‚Äî come check."            ‚îÇ
‚îÇ              ‚îÇ  ‚Üí wakes ALL threads from wait set                ‚îÇ
‚îÇ              ‚îÇ  ‚Üí all compete for lock one by one                ‚îÇ
‚îÇ              ‚îÇ  ‚Üí each re-checks while condition                 ‚îÇ
‚îÇ              ‚îÇ  ‚Üí safer than notify() in most cases              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ join()       ‚îÇ "I won't proceed until YOU are completely done."  ‚îÇ
‚îÇ              ‚îÇ  ‚Üí calling thread blocks until target dies        ‚îÇ
‚îÇ              ‚îÇ  ‚Üí implemented using wait() internally            ‚îÇ
‚îÇ              ‚îÇ  ‚Üí called FROM outside the thread                 ‚îÇ
‚îÇ              ‚îÇ  ‚Üí does NOT need synchronized block               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Key rules burned into memory:
  1. wait/notify MUST be called inside synchronized on the SAME object
  2. ALWAYS use while, never if ‚Äî re-check condition after every wakeup
  3. notify() wakes ONE, notifyAll() wakes ALL ‚Äî use notifyAll() when unsure
  4. join() is called by the waiting thread ON the target thread object
  5. join() is wait() under the hood ‚Äî when thread dies, JVM calls notifyAll()
```

Now when you see these methods in any codebase, you can picture the restaurant: waiters stepping back from the counter, chefs ringing bells, and the manager waiting for everyone to clock out before writing the closing report.