# Java Fundamentals
### 1. Java Architecture & Environment
- [ ] **JDK, JRE, and JVM** (Differences and Roles)
- [ ] **JVM Architecture** (Class Loader, Execution Engine, Native Interface)
- [ ] **Memory Model** (Stack Memory vs. Heap Memory)
- [ ] **Bytecode** (.java to .class compilation process)
- [ ] **Garbage Collection** (Basic concepts: Mark-and-Sweep, eligibility for GC)
- [ ] **Main Method** (Significance of `public static void main(String[] args)`)

### 2. Basics, Data Types & Variables
- [ ] **Primitive Data Types** (int, char, boolean, byte, short, long, float, double)
- [ ] **Wrapper Classes** (Integer, Double, Boolean - Auto-boxing & Unboxing)
- [ ] **Literals** (Integral, Floating-point, Character, String literals)
- [ ] **Type Casting** (Implicit/Widening vs. Explicit/Narrowing)
- [ ] **Variable Scope** (Instance vs. Class/Static vs. Local variables)
- [ ] **Operators** (Arithmetic, Relational, Logical, Bitwise, Ternary)

### 3. Control Flow
- [ ] **Conditional Statements** (`if`, `else-if`, `else`)
- [ ] **Switch Statement** (Old syntax vs. Java 12+ Switch Expressions, `yield`)
- [ ] **Loops** (`for`, `while`, `do-while`, Enhanced `for-each` loop)
- [ ] **Branching** (`break`, `continue`, `return`)

### 4. Object-Oriented Programming (OOP) Pillars
- [ ] **Classes & Objects** (Blueprints vs. Instances)
- [ ] **Constructors** (Default, Parameterized, Copy Constructor)
- [ ] **Constructor Chaining** (`this()` vs `super()`)
- [ ] **Encapsulation** (Getters, Setters, Data Hiding)
- [ ] **Inheritance** (`extends` keyword, Single, Multilevel, Hierarchical)
- [ ] **Polymorphism** (Compile-time/Overloading vs. Runtime/Overriding)
- [ ] **Abstraction** (Concept of hiding implementation details)

### 5. Modifiers & Keywords
- [ ] **Access Modifiers**
    - [ ] `private`
    - [ ] `default` (package-private)
    - [ ] `protected`
    - [ ] `public`
- [ ] **Non-Access Modifiers**
    - [ ] `static` (blocks, methods, variables, classes)
    - [ ] `final` (variables, methods, classes)
    - [ ] `abstract` (methods, classes)
    - [ ] `native`, `transient`, `volatile` (High-level awareness)
- [ ] **Other Keywords**
    - [ ] `this` (Current instance reference)
    - [ ] `super` (Parent instance reference)
    - [ ] `instanceof` (Type checking)
### 6. Interfaces & Abstract Classes
- [ ] **Abstract Classes** (Partial abstraction, constructors in abstract classes)
- [ ] **Interfaces** (Full abstraction contract)
- [ ] **Interface Evolution (Java 8+)**
    - [ ] `default` methods
    - [ ] `static` methods in interfaces
    - [ ] `private` methods in interfaces (Java 9)
- [ ] **Functional Interfaces** (Intro to interfaces with single abstract method)
- [ ] **Marker Interfaces** (Cloneable, Serializable)

### 7. String Handling (The Master Topic)
- [ ] **String Immutability** (Why and How)
- [ ] **String Memory** (String Constant Pool vs. Heap)
- [ ] **Comparison** (`==` vs `.equals()`)
- [ ] **String Methods** (length, substring, trim, replace, indexOf, etc.)
- [ ] **String vs StringBuilder vs StringBuffer** (Mutability and Thread-safety)
- [ ] **String Interning** (`intern()` method)
### 8. Arrays
- [ ] **Array Declaration & Initialization** (1D Arrays)
- [ ] **Multidimensional Arrays** (2D Matrices, Jagged Arrays)
- [ ] **Array Memory Model** (Arrays are Objects)
- [ ] **java.util.Arrays** (Utility methods: `sort`, `binarySearch`, `toString`)
- [ ] **Varargs** (`Type... args` syntax)

### 9. Nested Classes (Inner Classes)
- [ ] **Member Inner Class** (Non-static)
- [ ] **Static Nested Class**
- [ ] **Local Inner Class** (Inside methods)
- [ ] **Anonymous Inner Class** (Ad-hoc overrides)

### 10. Exception Handling
- [ ] **Exception Hierarchy** (Throwable -> Error vs. Exception)
- [ ] **Checked vs. Unchecked Exceptions**
- [ ] **Keywords** (`try`, `catch`, `finally`, `throw`, `throws`)
- [ ] **Try-with-resources** (AutoCloseable interface)
- [ ] **Custom Exceptions** (Creating your own)
- [ ] **Best Practices** (Exception swallowing, catch block ordering)

### 11. Enumerations (Enums)
- [ ] **Basic Enum Definition**
- [ ] **Enums with Fields and Constructors**
- [ ] **Enum Methods** (`values()`, `valueOf()`, `ordinal()`)

### 12. Object Class Methods (The Root)

- [ ] **toString()**
- [ ] **equals() and hashCode() Contract**
- [ ] **clone()** (Shallow vs Deep Copy)
- [ ] **finalize()** (Deprecated, but good to know history)

# Collection
### 1. The Hierarchy & Interfaces
- [ ] **The Collection Interface** (Methods: `add`, `remove`, `size`, `contains`, `iterator`)
- [ ] **The Map Interface** (Distinct from Collection hierarchy)
- [ ] **Iterable vs. Iterator** (The `hasNext()` and `next()` mechanism)
- [ ] **fail-fast vs. fail-safe Iterators** (Concept of `ConcurrentModificationException`)

### 2. List Interface (Ordered, Duplicates Allowed)
- [ ] **ArrayList** (Resizable Array implementation)
    - [ ] Internal resizing logic (50% growth vs 100%)
    - [ ] Time Complexity ($O(1)$ get vs $O(n)$ shift on remove)
- [ ] **LinkedList** (Doubly Linked List implementation)
    - [ ] Node structure (prev, next, data)
    - [ ] When to use over ArrayList (Insert/Delete at ends)
- [ ] **Vector & Stack** (Legacy classes)
    - [ ] Why they are obsolete (Synchronization overhead)
- [ ] **CopyOnWriteArrayList** (Thread-safe variant basics)

### 3. Set Interface (Unique, No Duplicates)
- [ ] **HashSet** (Unordered, backed by HashMap)
    - [ ] Role of `hashCode()` and `equals()` in uniqueness
- [ ] **LinkedHashSet** (Insertion order preserved)
    - [ ] Underlying Doubly Linked List maintenance
- [ ] **TreeSet** (Sorted order)
    - [ ] Red-Black Tree basics
    - [ ] `NavigableSet` interface methods (`lower`, `higher`, `floor`, `ceiling`)

### 4. Map Interface (Key-Value Pairs)
- [ ] **HashMap** (The King of Collections)
    - [ ] Internal Architecture (Buckets, Nodes, Linked Lists)
    - [ ] Java 8 Treeification (Linked List $\to$ Red-Black Tree threshold)
    - [ ] `loadFactor` (0.75) and Rehashing/Resizing
    - [ ] Collision Resolution (Chaining)
- [ ] **LinkedHashMap** (Preserves order)
    - [ ] Access Order vs. Insertion Order (Building LRU Caches)
- [ ] **TreeMap** (Sorted Keys)
    - [ ] Sorting mechanism (Natural ordering or Custom Comparator)
- [ ] **WeakHashMap** (Garbage Collection interaction)
- [ ] **IdentityHashMap** (Reference equality vs Object equality)

### 5. Queue & Deque Interface
- [ ] **PriorityQueue**
    - [ ] Min-Heap vs Max-Heap structure
    - [ ] Usage in "Top K elements" problems
- [ ] **ArrayDeque** (Double Ended Queue)
    - [ ] Why it is faster than `Stack` class
    - [ ] Using it as a Stack (LIFO) or Queue (FIFO)
- [ ] **BlockingQueue** (Brief awareness for Producer-Consumer)

### 6. Ordering & Sorting
- [ ] **Comparable Interface** (`compareTo` method - Natural Ordering)
- [ ] **Comparator Interface** (`compare` method - Custom Ordering)
- [ ] **Collections.sort()** internal algorithm (Timsort - Merge Sort + Insertion Sort)
### 7. The `Collections` Utility Class
- [ ] **Sorting & Searching** (`sort`, `binarySearch`)
- [ ] **Shuffling** (`shuffle`)
- [ ] **Unmodifiable Wrappers** (`unmodifiableList`, `unmodifiableMap`)
- [ ] **Synchronization Wrappers** (`synchronizedList`, etc.)
- [ ] **Singleton/Empty constants** (`emptyList`, `singletonList`)
### 8. Java 8+ Enhancements
- [ ] **forEach** method
- [ ] **removeIf** (Predicate-based removal)
- [ ] **stream()** and **parallelStream()** initiation
- [ ] **Map enhancements** (`getOrDefault`, `putIfAbsent`, `computeIfAbsent`, `merge`)

### 9. Time Complexity (Big O) Cheat Sheet
- [ ] **Access/Search** cost for ArrayList vs LinkedList vs HashMap vs TreeMap
- [ ] **Insertion/Deletion** cost for the above
- [ ] **Memory Overhead** comparisons

### 10. Concurrent Collections (The "Must Know" Basics)
_Even if avoiding deep multithreading, you must know these exist._
- [ ] **ConcurrentHashMap** (Segment locking/CAS vs Global locking)
- [ ] **ConcurrentLinkedQueue** (Non-blocking queue)

# Multithreading & Concurrency
For SDE-2 roles, the focus shifts heavily from "how to create a thread" to "how to manage threads efficiently" (Executors) and "how to handle asynchronous data flow" (CompletableFuture).
### 1. The Fundamentals
- [ ] **Thread Creation** (Extending `Thread` vs Implementing `Runnable`)
- [ ] **Thread Lifecycle** (New, Runnable, Running, Blocked, Waiting, Timed_Waiting, Terminated)
- [ ] **Key Methods**
    - [ ] `start()` vs `run()` (Why calling run doesn't start a thread)
    - [ ] `sleep()` vs `yield()`
    - [ ] `join()` (Waiting for a thread to finish)
    - [ ] `setDaemon()` (Daemon vs User threads)
### 2. Synchronization & Thread Safety
- [ ] **The `synchronized` Keyword**
    - [ ] Synchronized Method vs Synchronized Block
    - [ ] Object Lock (Monitor) vs Class Lock (`static synchronized`)
- [ ] **The `volatile` Keyword** (Visibility guarantee, "Happens-Before" relationship)
- [ ] **ThreadLocal** (Per-thread variable isolation)
- [ ] **Race Conditions** (What they are and how to spot them)
### 3. Inter-Thread Communication (Legacy)
- [ ] **wait(), notify(), notifyAll()**
    - [ ] Why are these in `Object` class and not `Thread`?
    - [ ] Why must they be called inside a `synchronized` context?
    - [ ] The "Spurious Wakeup" problem (Why use `while` loop check, not `if`)
### 4. The Executor Framework (Modern Concurrency)
- [ ] **ExecutorService Interface**
    - [ ] `submit()` vs `execute()`
    - [ ] `shutdown()` vs `shutdownNow()`
- [ ] **Thread Pools** (`Executors` factory)
    - [ ] `FixedThreadPool`
    - [ ] `CachedThreadPool`
    - [ ] `ScheduledThreadPool`
    - [ ] `SingleThreadExecutor`
- [ ] **Callable & Future**
    - [ ] Difference between `Runnable` and `Callable` (Return values & Exceptions)
    - [ ] `Future.get()` (Blocking behavior)
### 5. Java 8+ Asynchronous Programming
- [ ] **CompletableFuture** (Critical for Microservices)
    - [ ] `supplyAsync`, `runAsync`
    - [ ] Chaining: `thenApply`, `thenAccept`, `thenRun`
    - [ ] Combining: `thenCompose` (FlatMap equivalent), `thenCombine`
    - [ ] Exception Handling: `exceptionally`, `handle`
### 6. Concurrent Collections
- [ ] **ConcurrentHashMap** (Deep dive into CAS + Node Locking)
- [ ] **CopyOnWriteArrayList** (Read-heavy scenarios)
- [ ] **BlockingQueue**
    - [ ] `ArrayBlockingQueue` vs `LinkedBlockingQueue`
    - [ ] Usage in **Producer-Consumer** pattern (replacing wait/notify)
### 7. Locks & Atomic Variables
- [ ] **ReentrantLock** (vs `synchronized`: Fairness, `tryLock`)
- [ ] **ReadWriteLock** (Optimizing for high reads, low writes)
- [ ] **Atomic Classes** (`AtomicInteger`, `AtomicReference`)
    - [ ] Understanding **CAS** (Compare-And-Swap) hardware instruction (Optimistic Locking)
### 8. Advanced Synchronizers (SDE-2 Focus)
- [ ] **CountDownLatch** (Wait for N tasks to finish)
- [ ] **CyclicBarrier** (Wait for threads to meet at a point)
- [ ] **Semaphore** (Permit management / Rate limiting)
### 9. Common Problems & Concepts
- [ ] **Deadlock** (Conditions, Prevention, Analysis via Thread Dump)
- [ ] **Livelock** & **Starvation**
- [ ] **Context Switching** (The cost of concurrency)

# SpringBoot
### 1. The Spring Ecosystem (The Framework)
- **Spring Core:** Dependency Injection (DI) & Inversion of Control (IoC).
- **Spring Boot:**
    - Auto-configuration magic (How does `@SpringBootApplication` work?).
    - Starters & Embedded Servers (Tomcat).
    - `application.properties` vs `.yml` & Profiles (Dev/Prod).
- **Spring MVC / REST:**
    - Annotations: `@RestController`, `@RequestMapping`, `@RequestBody`, `@PathVariable`, `@RequestParam`.
    - HTTP Verbs & Status Codes (200, 201, 400, 401, 403, 404, 500).
- **Spring Security:** Basic Auth, JWT workflow, Filter Chains.
- **Spring AOP:** Cross-cutting concerns (Logging, Transaction management).

### 3. Data Persistence (JPA / Hibernate / SQL)
- **ORM Concepts:** Entity lifecycle (Transient, Persistent, Detached).
- **Annotations:** `@Entity`, `@Id`, `@GeneratedValue`, `@OneToMany`/`@ManyToOne`.
- **Performance Hotspots:** The **N+1 Problem** (and how to fix it with `JOIN FETCH`).
- **Transactions:** `@Transactional` propagation levels & isolation levels.
- **SQL Basics:** Joins, Group By, Indexes, Normalization.

### 4. System Design (Low Level & High Level)
- **Design Patterns:** Singleton, Factory, Builder, Observer, Strategy, Decorator.
- **SOLID Principles:** Be able to explain them with code examples.
- **Microservices Basics (SDE-2 Focus):**
    - Monolith vs Microservices.
    - Inter-service communication (RestTemplate vs FeignClient).
    - Circuit Breaker Pattern (Resilience4j).
    - API Gateway concept.

### 5. Testing & Tools
- **Unit Testing:** JUnit 5 (Lifecycle annotations `@BeforeEach`, etc.).
- **Mocking:** Mockito (`@Mock` vs `@InjectMocks`, `when().thenReturn()`).
- **Build Tools:** Maven (Lifecycle, `pom.xml` structure, dependency management).
- **Version Control:** Git flows (Merge vs Rebase, Cherry-pick).