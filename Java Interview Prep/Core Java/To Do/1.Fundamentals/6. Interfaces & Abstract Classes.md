
### 6. Interfaces & Abstract Classes
- [ ] **Abstract Classes** (Partial abstraction, constructors in abstract classes)
- [ ] **Interfaces** (Full abstraction contract)
- [ ] **Interface Evolution (Java 8+)**
    - [ ] `default` methods
    - [ ] `static` methods in interfaces
    - [ ] `private` methods in interfaces (Java 9)
- [ ] **Functional Interfaces** (Intro to interfaces with single abstract method)
- [ ] **Marker Interfaces** (Cloneable, Serializable)


## Marker Interfaces (Cloneable, Serializable)
### 1. The Basics (The "What")
- **Definition:** An interface with **no methods, fields, or constants**. It is empty.
- **Purpose:** It acts as a **Tag** or **Signal** to the compiler, JVM, or a framework. It says, _"Treat this object specifically."_
- **Mechanism:** The JVM or library code checks for the presence of this interface using the `instanceof` operator.
### 2. The "Big 4" Examples (Memorize These)

| **Interface**      | **Package** | **Purpose**                                                                   |
| ------------------ | ----------- | ----------------------------------------------------------------------------- |
| **`Serializable`** | `java.io`   | Signals JVM that this *object can be* converted to bytes (serialized).        |
| **`Cloneable`**    | `java.lang` | Signals `Object.clone()` that **it is legal to make a field-for-field copy**. |
| **`RandomAccess`** | `java.util` | Signals that a List *supports* fast $O(1)$ index access (e.g., `ArrayList`).  |
| **`Remote`**       | `java.rmi`  | Signals that an *object can be* accessed from another JVM (RMI).              |

---
### 3. Top Interview Questions & Answers

#### Q1: How does a Marker Interface actually work if it has no methods?
It works via <mark style="background-color: #fff88f; color: black">Runtime Type Checking</mark>.
The Java API code (like `ObjectOutputStream` for serialization) explicitly checks:

```Java
if (obj instanceof Serializable) {
    // Proceed with serialization
} else {
    throw new NotSerializableException();
}
```

It is essentially a boolean flag baked into the Type System.
#### Q2: Why use a Marker Interface instead of a boolean flag inside the class?
**Answer:** <mark style="background-color: #fff88f; color: black">Polymorphism</mark>.
- A boolean flag is internal state. You have to instantiate the object to check it.
- **A Marker Interface is a Type**. You can write methods that accept only marked objects:
    public void save(Serializable obj) { ... }
    This provides Compile-time safety.
#### Q3: Marker Interface vs. <mark style="background-color: #fff88f; color: black">Annotations</mark>? (The SDE-2 Question)
Since Java 5 introduced Annotations (`@Entity`, `@Serializable`), <mark style="background-color: #fff88f; color: black">why do we still use Marker Interfaces?</mark>

|**Feature**|**Marker Interface**|**Annotation**|
|---|---|---|
|**Polymorphism**|**YES**. Can be used as a variable type (`Serializable s = new User()`).|**NO**. Cannot say `Entity e = new User()`.|
|**Inheritance**|**YES**. Child classes automatically inherit the marker.|**Depends**. Only if `@Inherited` is used.|
|**Parameters**|**NO**. It is just a flag.|**YES**. Can pass values (`@Table(name="users")`).|
|**Modern Usage**|Rare. mostly legacy or utility types (`RandomAccess`).|Preferred for metadata.|
#### Q4: Why is `Cloneable` considered a "Broken" design?
**Answer:**
1. **Contradiction:** Usually, an interface tells you _what an object can do_ (its methods). `Cloneable` says "I can be cloned," but it **does not** contain the `clone()` method (that is in `Object`).
2. **Confusion:** Implementing `Cloneable` changes the behavior of a protected method (`Object.clone()`) from throwing an exception to succeeding. This is "spooky action at a distance."
#### Q5: What is `SerialVersionUID`?
**Answer:** It is a unique ID used during Deserialization to verify that the sender and receiver of a serialized object have loaded classes that are compatible. If you don't define it, Java generates one based on class structure, which causes errors if you change the class even slightly.

Set of questions that you can expect on Serialization : 
- Transient vs. static vs. final keywords in Serialization
- Externalization vs. Serialization
- SerialVersionUID
- what is Customised Serialization

---
### 4. Code Challenge: Create a Custom Marker
**Scenario:** Create a system where only "Safe" objects can be deleted from the DB.

```Java
// 1. Define the Marker
public interface Deletable {
    // Empty
}

// 2. Mark a class
public class User implements Deletable {
    // ...
}

public class Admin { 
    // Not Deletable
}

// 3. The Utility Logic
public void deleteEntity(Object entity) {
    if (entity instanceof Deletable) {
        // Run delete SQL
        System.out.println("Deleted.");
    } else {
        throw new SecurityException("This object cannot be deleted!");
    }
}
```
