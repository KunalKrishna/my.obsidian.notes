4.Object-Oriented Programming (OOP) Pillars
- [ ] **Classes & Objects** (Blueprints vs. Instances)
- [ ] **Constructors** (Default, Parameterized, Copy Constructor)
- [ ] **Constructor Chaining** (`this()` vs `super()`)
- [ ] **Encapsulation** (Getters, Setters, Data Hiding)
- [ ] **Inheritance** (`extends` keyword, Single, Multilevel, Hierarchical)
- [ ] **Polymorphism** (Compile-time/Overloading vs. Runtime/Overriding)
- [ ] **Abstraction** (Concept of hiding implementation details)

## Encapsulation
### 1. What is Encapsulation?
Encapsulation is the **bundling** of data (instance variables) and the methods that operate on that data into a single unit (a Class). It is often called **"Data Hiding"** because it prevents external classes from seeing or modifying the internal state of an object directly.
### 2. Why is it Important?
- **Data Integrity:** It ensures that an object’s state is always valid (e.g., an `Employee`’s salary cannot be negative).
- **Flexibility & Maintenance:** You can change the internal implementation (like changing a `List` to a `Set`) without breaking the code of anyone using your class.
- **Security:** It protects sensitive data from unauthorized or accidental modification.
### 3. How is it Achieved?
In Java, we achieve encapsulation using two main steps:
1. **Private Fields:** Declare class variables as `private`.
2. **Public Accessors:** Provide `public` getter and setter methods to access and update those variables. 
### 4. Direct Access vs. Getters/Setters
This is a favorite interview follow-up. The problem with **Direct Access** is that it offers zero control.
#### Scenario: Direct Access (The Problem)

```Java
public class Account {
    public double balance; // Direct access allowed
}
// Any outside class can do this:
account.balance = -5000; // Oops! Negative balance is logically impossible.
```
#### Scenario: Getter/Setter (The Solution)
Getters and setters act as **"Gatekeepers."** They overcome direct access issues by adding a layer of logic between the data and the user.

| **Feature**                                                                       | **Direct Access**                         | **Getter / Setter (Encapsulation)**                                                                                                                     |
| --------------------------------------------------------------------------------- | ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Validation**                                                                    | None. Any value can be assigned.          | **Controlled.** You can check `if (amount > 0)` before updating.                                                                                        |
| **Read/Write Control**                                                            | Always both.                              | **Granular.** Provide only a getter for a "Read-Only" field.                                                                                            |
| <mark style="background-color: #fff88f; color: black">**Abstraction**</mark>      | Changes to the field name break all code. | **Hidden.** <mark style="background-color: #fff88f; color: black">You can rename the field `bal`</mark> to `amount` and keep the method `getBalance()`. |
| <mark style="background-color: #fff88f; color: black">**Logging/Auditing**</mark> | Impossible to track changes.              | **Easy.** You can log every time a value is changed inside the setter.                                                                                  |

Hibernate and Jackson rely on these getters/setters (JavaBeans convention) to map your database rows or JSON to Java objects automatically

----

## Inheritance 
[Inheritance (The Java™ Tutorials \> Learning the Java Language \> Interfaces and Inheritance)](https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html)

- Types
- IS-A relationship 
- Method overriding
- Constructor : [Constructors in Java: Types, Example Programs, Full Guide](https://www.wscubetech.com/resources/java/constructors)
	- Constructor chaining:  "Single Object" Reality : Memory model when creating subclass object
	- Private Constructor
- Keywords : `super()` and `this()` , `instanceof`, `@Override`, `final`
- Design principle : "favor composition over inheritance".


In Java, **Inheritance** is a mechanism where ==one class (the **subclass** or child) acquires the (non-private) **fields** and **methods** of another class (the **superclass** or parent)==. It promotes **code reusability** and establishes an **IS-A relationship**.

> Inheritance is a ==**mandatory** prerequisite for achieving runtime polymorphism in Java==, as it establishes the necessary "is-a" relationship between a superclass and its subclasses
#### 1. How it is Achieved
Inheritance is implemented using the `extends` keyword.
- **Superclass:** The class being inherited from.
- **Subclass:** The class that inherits. It can add its own fields/methods or override(enabling polymorphic behavior) existing ones.
#### 2. Types of Inheritance in Java
- **Single:** A -> B
- **Multilevel:** A -> B -> C e.g. `Child extends Parent`, `Parent extends Grandparent`
- **Hierarchical:** A -> B and A -> C e.g. `Car extends Vehicle`, `Bike extends Vehicle`
- **Multiple (NOT supported via Classes):** Java does not allow `class C` ~~`extends A, B`~~ to avoid the **Diamond Problem** (ambiguity if both parents have the same method). 
	- Multiple inheritance is achieved only through **Interfaces**.
- 

![[Types of Java Inheritance.png]]

```Java
public class Smartphone extends Device implements Camera, InternetBrowser {
    // implementation details
}
```
#### What You Can Do in a Subclass

A subclass inherits all of the _public_ and _protected_ members of its parent, no matter what package the subclass is in. If the subclass is in the same package as its parent, it also inherits the _package-private_ members of the parent. You can use the inherited members as is, replace them, hide them, or supplement them with new members : 

- The inherited fields can be used directly, just like any other fields. 
- You can declare a field in the subclass with the same name as the one in the superclass, thus _hiding_ it (not recommended).  
- You can declare new fields in the subclass that are not in the superclass. 
- The inherited methods can be used directly as they are. 
- ==You can write a new _instance_ method in the subclass that has the same signature as the one in the superclass, thus _overriding_ it.== 
- ==You can write a new== _==static==_ ==method in the subclass that has the same signature as the one in the superclass, thus== _==hiding==_ ==it.== 
- You can declare new methods in the subclass that are not in the superclass. 
- You can write a subclass constructor that invokes the constructor of the superclass, either implicitly or by using the keyword `super`. 

Private Constructor 
Why & When? 
- **Singleton Design Pattern:** To ensure only one object of a class is created throughout the application.
- **Factory Methods:** To prevent direct instantiation and instead provide a controlled way of object creation.
- **Utility/Helper Classes:** To prevent instantiation of classes that only contain static methods, like Math or Collections.


![[Pasted image 20260104085525.png]]